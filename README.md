# coding-experience-for-leetcode

python input EOFError:python3 stipulate the input function just can be called in father process

Bitmap:！！

<--------2021-04-06-------->
洗牌算法：
有一个大小为100的数组，里面的元素是1到100，怎样随机从里面选择50个数。
如果采用暴力算法，那么到后面选出来的随机数可能会在前面就已经出现过，使用set去重也会造成很大的时间复杂度开销。
洗牌算法的核心思想就是，对下标进行随机选择，按照顺序交换当前下标和随机下标里面的数字。这样即使随机到曾经出现的数也不会造成什么本次操作失效。
上述方法每一位只能出现99个数，虽然概率相等但是不够随机。可以将对下标的随机范围包括自己，这样每个数出现在某一位上的概率都是1/100。

在常数时间内完成向数组插入、删除、随机选取一个数的操作。
核心办法：通过hash函数完成元素值到下标的映射，这样在检索就可以通过hash映射在常数时间内找到对应值的索引，完成查找这一动作。
随机选取一个数可以直接对数组操作，通过随机下标的方式选出随机数。
在C++中，unordered_map采用STL标准库提供的hash函数进行map映射，该hash函数只适用于基本数据类型（包括string类型），并不能使用在自定义结构体或者类上面。容器模板中还表明了相等比较规则，改规则仅支持可以使用==符号进行比较的数据类型。
unordered_map类型的初始化为：
std::unordered_map<std::int,std::int> M_map;
成员函数：
begin()和end()都是返回迭代器；

empty()，若容器为空，返回true；否则false；

size()，返回容器存有的键值对的个数；

可以通过value=map[key]直接通过key值访问value值；

find()，查找以key为键的键值对，如果找到返回迭代器；否则==end()；

insert()，插入新的键值对；emplace()，向容器添加新的键值对，效率比前者高;

erase()，删除指定键值对；

clear()，清空容器；

swap()，交换两个容器的键值对，保证容器的类型完全相同。



