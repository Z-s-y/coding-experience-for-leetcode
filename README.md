# coding-experience-for-leetcode

python input EOFError:python3 stipulate the input function just can be called in father process

Bitmap:！！

线程与进程的区别和联系：
线程是进程执行运算的最小单位，是在cpu上实际调度的实体对象。线程被称为轻量级进程，只能拥有运行时一些必须的资源，但是可以和同进程的其他线程共享系统资源。
进程是分配和管理资源的基本单位，是一个动态概念。
地址空间：线程共享本进程的地址空间，进程之间的地址空间是独立的。
资源：线程与同进程的其他线程共享资源，而进程之间的资源是独占的。
健壮性：多进程的某一进程崩溃不会导致进程崩溃，多线程中的某一线程崩溃整个进程都死掉了。
执行过程：每个进程都有程序运行入口，执行开销大，；由应用程序提供多线程执行控制，执行开销小。
可并发性：两者均可并发。

协程：比线程更加轻量级，一个线程可以拥有多个协程。

死锁的原因：
产生死锁的4个必要条件：互斥条件（资源独占）、请求保持、不剥夺条件（已获得资源未使用完成时不能剥夺，只能自己释放）、环路等待条件。
预防死锁的基本方法：资源一次分配，如果有一个资源得不到分配剩下的都不分配（其实与上述同），可剥夺资源，资源有序分配法（破坏环路等待情况）

虚拟内存：计算机系统内存管理的一种技术，应用程序认为它拥有连续可用的内存，实际上，通常被分隔成多个物理内存碎片，还有部分暂时存储在磁盘存储器上，在需要时将数据调入。调度方式有分页式、分段式、段页式。页式的优点是页内碎片小，地址变换快；但是页内的内容不是程序的独立模块，不利于程序和数据的保护。段式按照程序的逻辑结构划分地址空间，段的长度式随意的。其优点是消除了内存碎片，易于存储保护，便于动态装配；但是调入操作复杂。段页式先将程序逻辑结构分段，再按照实际内存的大小将段分页，程序按照页式进行调入和调出操作，同时可以实现共享和保护。缺点是地址映射过程需要多次查表。
常见的调度算法：随机算法、先进先出、近期最少使用算法。最优算法（基准算法）

常见排序算法：
1、冒泡排序：O(n^2)。按照排序规则交换相邻两个元素，每次都可以让无序部分的最大值或者最小值“冒出”。
2、选择排序：稳定与否看实现模式。每次从排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置。
   堆排序：O(nlogn)。选择排序的一种，利用堆这种数据结构设计的排序算法，其性质满足子节点的值总是大于或者小于父节点。建堆：向下递归建树，向上递归调整满足条件（2n次操作）；将最大值下沉（放在无需部分的末尾，需对n个数据执行此类操作），调整堆符合最大堆要求（每次调整最多需要3logn次）。
3、插入排序：O(n^2)。假设前n-1个数有序，将第n个数插入到排好的序列中去。（哨兵比较法：从后往前比较）
   希尔排序：依赖于步长增量，通过步长分块，块之间的次序可以保证，然后缩短步长，直达整个数据有序。
4、归并排序：O(nlogn)分治思想。向下遍历分解，用合并排序算法对两个子序列排序，向上合并。
5、快速排序：最坏O(n^2)、平均O(nlogn)，但是实际性能会比这个优越。一趟排序将无序数据分成左右两个序列（可以是无序的），直到递归到整个序列有序为止。
6、基数排序：又称为“桶子法”，稳定的排序算法。
7、计数排序：计数排序是一个非基于比较的排序算法，优势在于对一定范围内的整数排序时，它的复杂度为O(n+k),其中k为整数的范围，快于任何比较排序算法。这是通过牺牲空间复杂度换取的，在O(k)>O(nlogn)的时候其效率反而不如基于比较的算法。扫描一遍，将出现的数字作为下标的标志位增加1，如果出现负数可以平移最小值。
排序稳定性：在序列中存在多个相同的关键字记录，如果经过排序，这些记录的相对次序保持不变，那么这样的算法时稳定的。
基本有序运用什么排序算法？快排是不行的，它的比较基数有很大可能选到坏的情况。插入排序比较好，从后往前遍历，可以很好地停止。如果存在二叉树里面，可以调整成为最大堆。

tcp的可靠性：tcp是一种面向连接的、可靠的、基于字节流的传输层通信协议。该技术在不可靠的IP协议上实现了可靠性。所谓的可靠性，就是接收端收到的数据流与发送端发出的数据流是完全相同的。是无损坏、无间隔、非冗余和按序的。
干扰导致的内容比特变化（噪声干扰），乱序（数据包到达的时间不同），丢包，冗余。
针对上面的问题，解决的方法是：
内容变换：16bit长的checksum字段，校验传输过程中数据是否发生变化，与数据签名差不多，如果不符合预期，将该数据包丢弃。
乱序：为报文加上序号，32bit长的sequence number字段，下一个sequence number = length + pre sequence number。该可以通过sequence number判断是否已经接收过该数据包，解决冗余问题。
丢包：32bit长的Acknowledgment number字段，发送接收方下次期待收到的seq值。如果产生丢包，发送方可能收不到ack，引入超时、重传机制。
补充细节：
1、每一个seq都会又一个ack吗？
不是的，ack可以延迟确认，又称为累计确认。对前面多个包连续确认，只需要更新下次期待接收的seq值即可。
2、每一个未确认报文都需要开启一个定时器吗？
每个未被确认的报文都单独配置一个计时器，这样开销太大了。当第一个数据包进入队列时，计时器启动了。如果超时，队列头部的数据包会被重发，然后重新计时，当收到ACK时计时器也会重启。所有数据都被确认的话，就关闭定时器。
3、三次重传机制，当一个接收方收到三个以上的重复ack时，接收方就会根据ack的值重传对应的报文而无需等待超时。

http与https：
http协议是超文本传输协议，是一种从Web服务器传输超文本标记语言（HTML）到本地浏览器的传送协议。
http是一个基于tcp/ip通信协议来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。
http协议一般采用客户端/服务器架构，一次请求流程：
1、dns域名解析得到服务器ip
2、发起tcp请求，3次握手建立连接
3、http请求
4、http响应
5、客户端将响应得到的HTML代码和资源渲染到前端展现给客户
无连接是指每次连接只处理一个请求。服务器处理完请求，收到客户端的应答以后，即断开连接。
无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息时，必须通过重传得到。
TCP的面向连接是基于传输层的数据传输；HTTP的无连接是基于应用层面的沟通交互。
https就是http+ssl（安全套接字层）：经过对称密钥加密之后的密文通信。



   
   
